\documentclass[bachelor, och, labwork]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage{subfigure}
\usepackage{tikz,pgfplots}
\pgfplotsset{compat=1.5}
\usepackage{float}

%\usepackage{titlesec}
\setcounter{secnumdepth}{4}
%\titleformat{\paragraph}
%{\normalfont\normalsize}{\theparagraph}{1em}{}
%\titlespacing*{\paragraph}
%{35.5pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\titleformat{\paragraph}[block]
{\hspace{1.25cm}\normalfont}
{\theparagraph}{1ex}{}
\titlespacing{\paragraph}
{0cm}{2ex plus 1ex minus .2ex}{.4ex plus.2ex}

% --------------------------------------------------------------------------%


\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage{tempora}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}

\usepackage[colorlinks=false]{hyperref}
\usepackage{url}

\usepackage{underscore}
\usepackage{setspace}
\usepackage{indentfirst} 
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{enumitem}
\usepackage{tikz}
\usepackage{minted}

\newcommand{\eqdef}{\stackrel {\rm def}{=}}
\newcommand{\specialcell}[2][c]{%
\begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\renewcommand\theFancyVerbLine{\small\arabic{FancyVerbLine}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{теоретических основ компьютерной безопасности и криптографии}

% Тема работы
\title{Арифметические операции в числовых полях}

% Курс
\course{5}

% Группа
\group{531}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
\department{факультета КНиИТ}

% Специальность/направление код - наименование
%\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{010500 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{230100 "--- Информатика и вычислительная техника}
%\napravlenie{231000 "--- Программная инженерия}
\napravlenie{100501 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
% \studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Окуньков Сергей Викторович}

% Заведующий кафедрой
% \chtitle{} % степень, звание
% \chname{}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{профессор} %должность, степень, звание
\saname{В. А. Молчанов}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
% \patitle{к.ф.-м.н.}
% \paname{С.~В.~Миронов}

% Семестр (только для практики, для остальных
% типов работ не используется)
%\term{8}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
%\practtype{преддипломная}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
%\duration{4}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
%\practStart{30.04.2019}
%\practFinish{27.05.2019}

% Год выполнения отчета
\date{2023}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
% \secNumbering

%-------------------------------------------------------------------------------------------
\tableofcontents

\section{Постановка задачи}

    \textbf{Цель работы} - изучение основных операций в числовых полях и их
    программная реализация. 

    \begin{center}
        \textbf{Порядок выполнения работы:}
    \end{center}
    \begin{enumerate}
        \item Разобрать обычный, бинарный и расширенный алгоритмы Евклида
        вычисления наибольшего общего делителя целых чисел и привести их
        программную реализацию;
        \item Разобрать алгоритмы решения систем сравнений и привести их
        программную реализацию;
        \item Рассмотреть метод Гаусса решения систем линейных уравнений над
        конечными полями и привести его программную реализацию.
    \end{enumerate}

\section{Теоретические сведения}

    \subsection{Алгоритм поиска наибольшего общего делителя}
    \subsubsection{Алгоритм Евклида}

        \textbf{Алгоритм Евклида} вычисления наибольшего общего делителя целых
        чисел $a$ и $b
        > 0$ состоит из следующих этапов. Положим $a_0 = a$, $a_1 = b$ и выполним
        последовательно деления с остатком $a_i$ на $a_{i + 1}$:

        $$a_0 = a_1q_1 + a_2, 0 \leq a_2 < a_1,$$
        $$a_1 = a_2q_2 + a_3, 0 \leq a_3 < a_2,$$
        $$\cdots$$
        $$a_{k - 2} = a_{k - 1}q_{k - 1} + a_k, 0 \leq a_k < a_{k - 1},$$
        $$a_{k - 1} = a_k q_k.$$

        Так как остатки выполняемых делений образуют строго убывающую
        последовательность $a_1 > a_2  > \cdots > a_k \geq 0$, то этот процесс
        обязательно остановится в результате получения нулевого остатка деления.
        Легко видеть, что НОД($a_0, a_1$) = НОД($a_1, a_2$) = $\cdots$ =
        НОД($a_{k-1}, a_k$) = $a_k$. Значит, последний ненулевой остаток $a_k$ =
        НОД($a,b$).

    \subsubsection{Расширенный алгоритм Евклида}

        \textbf{Расширенный алгоритм Евклида} позволяет не только вычислять
        наибольший общий делитель целых чисел $a$ и $b > 0$, но и представлять
        его в виде НОД$(a, b)= ax+by$ для некоторых $x, y \in Z$. Значения $x,y$
        находятся в результате обратного прохода этапов алгоритма Евклида, в
        каждом из которых уравнение разрешается относительно остатка $a_i$,
        который представляется в форме $a_i = ax_i + by_i$ для некоторых $x_i,
        y_i \in Z$. 
        
        В результате получается следующая последовательность
        вычислений:

        \begin{minipage}{0.4\textwidth}
            $$a_0 = a,$$
            $$a_1 = b,$$
            $$a_2 = a_0 - a_1q_1,$$
            $$a_3 = a_1 - a_2q_2,$$
            $$ \cdots $$
          \end{minipage}
          \hfill
        \begin{minipage}{0.4\textwidth}
            $$a_0 = ax_0 + by_0,$$
            $$a_0 = ax_1 + by_1,$$
            $$a_2 = ax_2 + by_2,$$
            $$a_3 = ax_3 + by_3,$$
            $$ \cdots $$
        \end{minipage}

        \begin{minipage}{0.4\textwidth}
            $$a_i = a_{i - 2} - a_{i - 1}q_{i - 1},$$
            $$ \cdots $$
            $$a_k = a_{k - 2} - a_{k - 1}q_{k - 1},$$
            $$0 = a_{k - 1} - a_k q_k,$$
        \end{minipage}
          \hfill
        \begin{minipage}{0.4\textwidth}
            $$a_i = ax_i + by_i,$$
            $$ \cdots $$
            $$a_k = ax_k + by_k,$$
            $$0 = ax_{k + 1} + by_{k + 1}$$
        \end{minipage}

        В правом столбце все элементы $a_k, a_{k-1}, a_{k-2}, . . . , a_1, a_0$
        представляются в виде $a_i = ax_i + by_i$. Очевидно, что $x_0 = 1, y_0 =
        0, x_1 = 0, y_1 = 1$ и выполняются равенства: $a_i = a_{i-2} - a_{i-1}
        q_{i-1}, x_i = x_{i-2} - x_{i-1} q_{i-1}, y_i = y_{i-2} - y_{i-1}
        q_{i-1}$. Отсюда последовательно получаются искомые представления всех
        элементов $a_k, a_{k-1}, a_{k-2}, \dots, a_1, a_0$ и, в частности,
        представление НОД$(a,b) = a_k = ax_k +by_k$.

    \subsubsection{Бинарный алгоритм Евклида}

        \textbf{Бинарный алгоритм Евклида} "--- это ускоренный алгоритм для поиска
        наибольшего общего делителя двух чисел. Он основан на
        следующих свойствах:

        \begin{enumerate}
            \item НОД($2 \cdot a, 2 \cdot b$) = $2 \cdot$ НОД($a, b$);
            \item НОД($2 \cdot a, 2 \cdot b + 1$) = НОД($a, 2 \cdot b + 1$)
            \item НОД($-a, b$) = НОД($a, b$).
        \end{enumerate}

    \subsection{Алгоритмы решения систем сравнений}
    \subsubsection{Греко-китайская теорема об остатках}

        \textbf{Теорема.} Пусть $m_1, m_2, \dots , m_k$ – попарно взаимно
        простые целые числа и $M = m_1m_2 \cdots m_k$. Тогда система линейных
        сравнений


        \begin{equation}
            \begin{cases}
                x \equiv a_1 (mod \text{ } m_1)\\
                x \equiv a_2 (mod \text{ } m_2)\\
                \cdots\\
                x \equiv a_k (mod \text{ } m_k)\\              
            \end{cases}\,.
        \end{equation}
        
        имеет единственное неотрицательное решение по модулю $M$. 
        
        При этом, если для каждого $1 \leq j \leq n$ число $\frac{M}{m_j}$ 
        и сравнение $M_j x \equiv a_j (mod \text{ } m_j)$ имеет решение $z_j$,
        то решением системы линейных уравнений является остаток по модулю $M$
        числа $x = M_1 z_1 + M_2 z_2 + \dots + M_k z_k$.

    \subsubsection{Алгоритм Гарнера}

        Пусть $M = \prod_{i = 1}^{k} m_i$, числа $m_1, \dots, m_k$ попарно
        взаимно просты, и $c_{ij} \equiv m_i^{-1} (mod \text{ } m)_j, i \neq j,
        i,j \in 1, \dots, k.$ Тогда решение системы может быть представлено в
        виде

        $$x = q_1 + q_2 m_1 + q_3 m_2 + \dots + q_k m_1 \dots m_k,$$

        где $0 \leq q_i < m_i, i \in 1, \dots, k,$ и числа $q_i$ вычисляются по
        формулам

        $$q_1 = u_1 (mod \text{ } m_1)$$
        $$q_2 = (u_2 - q_1)c_{12} (mod \text{ } m_2)$$
        $$\dots$$
        $$q_ = (((u_k - q_1)c_{1k} - q_2)c_{2k} - \dots - q_{k-1})c_{k-1k} (mod \text{ } m)$$
    
    \subsection{Метод Гаусса решения систем линейных уравнений над конечными
    полями}

        Пусть $P = (P, +, \times, 1, 0)$ "--- произвольное поле.

        Системой $n$ линейных уравнений с $m$ неизвестными $x_1, \dots, x_m$
        называется выражение вида:
        
        \begin{equation}
            \begin{cases}
                a_{11} x_1 + a_{12} x_2 + \dots + a_{1m}x_m = b_1 \text{ } (1)\\            
                a_{21} x_1 + a_{22} x_2 + \dots + a_{2m}x_m = b_2 \text{ } (2)\\            
                \cdots\\
                a_{n1} x_1 + a_{n2} x_2 + \dots + a_{nm}x_m = b_n \text{ } (n),\\            
            \end{cases}\,.
        \end{equation}
        
        где $(1), (2), \dots, (n)$ "--- линейные уравнения с неизвестными $x_1,
        \dots, x_m$, коэффициентами $a_{11}, a_{12}, \dots, a_{nm} \in P$
        (первый индекс указывает номер уравнения, второй индекс – номер
        неизвестного) и свободными членами $b_1, \dots, b_n \in P$ (индекс –
        номер уравнения). При этом числа $a_{11}, a_{12}, \dots, a_{nm}$
        называются также коэффициентами системы и $b_1, \dots, b_n$ "---
        свободными членами системы.

        Система называется однородной, если $b_1 = \dots = b_n = 0$. 
        
        Система $(2)$ кратко записывается в виде $$\sum_{j = 1}^{m} a_{ij}
        x_j = b_i (i = 1, \dots, n).$$

        \textbf{Определение.} Решением системы $(2)$ называется такой упорядоченный набор $\zeta_1,
        \dots, \zeta_m \in P$ из $m$ элементов, что при подстановке в уравнения
        $(1)-(n)$ значений $x_1 = \zeta_1, \dots, x_m = \zeta_m$ получаются
        верные равенства $\sum_{j = 1}^{m} a_{ij} \zeta_j = b_i (i = 1, \dots,
        n)$. Такое решение сокращенно записывается в виде элемента $\zeta =
        (\zeta_1, \dots, x_m = \zeta_m)$ множества $P^{n}$.

        Множество всех решений системы $(2)$ обозначается символом $R(2)$.

        \textbf{Определение.} Система $(2)$ называется совместной, если у
        нее есть решения, и несовместной в противном случае. При этом
        совместная система называется определенной, если она имеет единственное
        решение, и неопределенной в противном случае.

        Решение систем осуществляется с помощью преобразований, которые сохраняют
        множество решений системы и поэтому называются равносильными.

        \textbf{Лемма 1} Следующие элементарные преобразования сохраняют множество
        решений любой системы линейных уравнений, т.е. являются равносильными:
        \begin{enumerate}
            \item удаление из системы тривиальных уравнений,
            \item умножение обеих частей какого-либо уравнения на одно и тот же ненулевой элемент поля,
            \item прибавление к обеим частям какого-либо уравнения системы соответствующих частей другого 
            уравнения системы.
        \end{enumerate}

        Метод решения системы $(2)$ заключается в равносильном преобразовании
        ее в систему линейных уравнений с противоречивым уравнением или в
        разрешенную систему линейных уравнений вида:

        \begin{equation}
            \begin{cases}
                x_1 + \dots + \dots + a'_{1,r+1}x_{r+1} + \dots + a'_{1,m}x_{m} = b'_1 \text{ } (1)\\            
                x_2 + \dots + a'_{2,r+1}x_{r+1} + \dots + a'_{2,m}x_{m} = b'_2 \text{ }(2)\\            
                \cdots\\
                x_r + a'_{r,r+1}x_{r+1} + \dots + a'_{r,m}x_{m} = b'_r \text{ } (r),\\            
            \end{cases}\,.
        \end{equation}

        где $r \leq n$, так как в процессе элементарных преобразований исходной
        системы удаляются тривиальные уравнения. В этом случае неизвестные $x_1,
        \dots, x_r$ называются разрешенными (или базисными) и $x_{r + 1}, \dots,
        x_m$ "--- свободными.

        Преобразование системы $(2)$ в равносильную ей разрешенную систему $(3)$
        осуществляется по методу Гаусса с помощью последовательного выполнения
        следующих Жордановых преобразований:

        \begin{enumerate}
            \item выбираем один из коэффициентов системы $a_{ij} \neq 0$;
            \item умножаем $i$-ое уравнение системы на элемент $a^{-1}_{ij}$;
            \item прибавляем к обеим частям остальных $k$-ых уравнений системы
            (здесь $k = 1, \dots, n, k \neq i)$ соответствующие части нового
            $i$-ого уравнения, умноженные на коэффициент "--- $a_{kj}$;
            \item удаляем из системы тривиальные уравнения (нулевые строки);
        \end{enumerate}

        При этом выбранный ненулевой элемент $a_{ij}$ называется разрешающим,
        строка и столбец, содержащие элемент $a_{ij}$, также называются
        разрешающими. Такие действия удобнее осуществлять над таблицей
        коэффициентов системы $(2)$, которая представляется в виде:

        $ \overline{A} =
        \begin{pmatrix}
            a_{11} & \cdots & a_{1m} & b_1 \\
            \cdots & \cdots & \cdots & \cdots \\
            a_{n1} & \cdots & a_{nm} & b_n \\
        \end{pmatrix}
        $ и называется матрицей системы $(2)$.

        Конечной целью применения метода Гаусса к системе линейных уравнений
        $(2)$ является преобразование с помощью Жордановых преобразований
        системы $(2)$ в равносильную ей разрешенную систему $(3)$.

        Матрица $\overline{A'}$ такой разрешенной системы $(3)$ имеет вид:

        $ \overline{A'} =
        \begin{pmatrix}
            1 & 0 & \cdots & 0 & a'_{1,r+1} & \cdots & a'_{1m} & b'_1 \\
            0 & 1 & \cdots & 0 & a'_{2,r+1} & \cdots & a'_{2m} & b'_2 \\
            \cdots & \cdots & \cdots & \cdots & \cdots & \cdots & \cdots \\
            0 & 0 & \cdots & 1 & a'_{r,r+1} & \cdots & a'_{rm} & b'_r \\
        \end{pmatrix}
        $

        Единичные столбцы матрицы $\overline{A'}$ будем называть разрешенными
        (или базисными), остальные столбцы с коэффициентами $a'_{ij}$ "---
        свободными. Строки, содержащие единицы базисных столбцов, называются
        разрешенными. Матрица называется разрешенной, если все ее строки
        разрешенные.

        Применение метода Гаусса к системе линейных уравнений $(2)$ в матричной
        форме равносильно преобразованию матрицы $\overline{A}$ этой системы в
        эквивалентную ей разрешенную матрицу $\overline{A'}$. При этом на каждом
        шаге метода Гаусса в преобразуемой матрице с помощью элементарных
        преобразований формируется новый единичный столбец.

\section{Результаты работы}
    \subsection{Описание алгоритмов Евклида вычисления НОД целых чисел}

        \underline{Алгоритм 1 - алгоритм Евклида}\\
            \textit{Вход}: целые числа $a, b$.\\
            \textit{Выход}: $d =$ НОД $(a, b)$.\\
            \underline{Шаг 1.} Положить $a_0 = a, a_1 = b, i = 1$.\\
            \underline{Шаг 2.} Найти остаток $a_{i + 1}$ от деления $a_{i - 1}$
            на $a_i$.\\
            \underline{Шаг 3.} Если $a_{i + 1} = 0$, то положить $d = a_i$.
            Иначе "--- положить $i = i + 1$ и вернуться к шагу $2$.\\
            \underline{Шаг 4.} Результат: $d =$ НОД $(a, b)$.\\
            
        \underline{Псевдокод:}
            \begin{minted}[breaklines,fontsize=\small]{text}
            Алгоритм Евклида(a, b):
            если b = 0 то
                вернуть a
            иначе
                вернуть Алгоритм Евклида(b, a % b)        
            \end{minted}
            
            Сложность алгоритма $O(\log(\min\{a, b\}))$.\\

        \underline{Алгоритм 2 - расширенный алгоритм Евклида}\\
            \textit{Вход}: целые числа $a, b$.\\
            \textit{Выход}: $d =$ НОД $(a, b)$ и коэффициенты $x, y$.\\
            \underline{Шаг 1.} Положить $a_0 = a, a_1 = b, x_0 = 1, y_0 = 0, x_1
            = 0, x_1 = 1, i = 1$.\\ 
            \underline{Шаг 2.} Найти остаток $a_{i + 1}$ от деления $a_{i - 1}$
            на $a_i$.\\
            \underline{Шаг 3.} Найти $x_{i + 1} = x_{i - 1} - (\frac{a_{i - 1}}{a_i} \cdot x_i)$.\\
            \underline{Шаг 4.} Найти $y_{i + 1} = y_{i - 1} - (\frac{a_{i - 1}}{a_i} \cdot y_i)$.\\
            \underline{Шаг 5.} Если $a_{i + 1} = 0$, то положить $d = a_i, x =
            x_i, y = y_i$. Иначе положить $i = i + 1$ и перейти к шагу $2$.\\
            \underline{Шаг 6.} Результат: $d =$ НОД $(a, b)$ и коэффициенты $x,
            y$.\\
            
        \underline{Псевдокод:}
            \begin{minted}[breaklines,fontsize=\small]{text}
            Расширенный алгоритм Евклида(a, b):
            если b = 0 то
                вернуть (a, 1, 0)
            иначе
                (d, x, y) := Расширенный алгоритм Евклида(b, a % b)
                вернуть (d, y, x - (a / b) * y)                
            \end{minted}

            Сложность алгоритма $O(\log(\min\{a, b\}))$.\\


        \underline{Алгоритм 3 - бинарный алгоритм Евклида}\\
            \textit{Вход}: целые числа $a, b$.\\
            \textit{Выход}: $d =$ НОД $(a, b)$.\\
            \underline{Шаг 1.} Положить $a_0 = a, a_1 = b$.\\ 
            \underline{Шаг 2.} Если $a = 0$, положить $d = b$.\\
            \underline{Шаг 3.} Если $b = 0$, положить $d = a$.\\
            \underline{Шаг 4.} Если $a = b$, положить $d = a$.\\
            \underline{Шаг 5.} Если $a = 1$ или $b = 1$, положить $d = 1$.\\
            \underline{Шаг 6.} Если $a$ и $b$ четные, положить $d = 2 \cdot$ бинарный алгоритм Евклида
            $(a / 2, b / 2)$.\\
            \underline{Шаг 7.} Если $a$ четное и $b$ нечетное, положить $d =$
            бинарный алгоритм Евклида $(a / 2, b)$.\\
            \underline{Шаг 8.} Если $a$ нечетное и $b$ четное, положить $d =$
            бинарный алгоритм Евклида $(a, b / 2)$.\\
            \underline{Шаг 9.} Если $a$ и $b$ нечетные и $b > a$, положить $d =$
            бинарный алгоритм Евклида $((b - a) / 2, a)$.\\
            \underline{Шаг 10.} Если $a$ и $b$ нечетные и $a > b$, положить $d =$
            бинарный алгоритм Евклида $((a - b) / 2, b)$.\\
            \underline{Шаг 11.} Результат: $d$.\\

        \underline{Псевдокод:}
            \begin{minted}[breaklines,fontsize=\small]{text}
            Бинарный алгоритм Евклида(a, b):
            если a = b то
                вернуть a
            если a = 0 то
                вернуть b
            если b = 0 то
                вернуть a
            если a чётное и b чётное то
                вернуть 2 * Бинарный алгоритм Евклида(a/2, b/2)
            если a чётное и b нечётное то
                вернуть Бинарный алгоритм Евклида(a/2, b)
            если a нечётное и b чётное то
                вернуть Бинарный алгоритм Евклида(a, b/2)
            если a и b нечётные то
                если a > b то
                    вернуть Бинарный алгоритм Евклида((a-b)/2, b)
                иначе
                    вернуть Бинарный алгоритм Евклида((b-a)/2, a)                      
            \end{minted}

            Сложность алгоритма $O(\log(\min\{a, b\})^2)$.\\
        
    \subsection{Описание  алгоритмов  решения систем сравнений}

        \underline{Алгоритм 4 - решение системы сравнений с помощью греко-китайской}\\
        \underline{теоремы об остатках}\\
            \textit{Вход}: целые числа $a_1, a_2, \dots, a_n$, являющиеся коэффициентами системы линейных сравнений и $m_1, m_2,
            \dots, m_n$ - сопростые числа, представляющие из себя модули этой системы.\\
            \textit{Выход}: целое число $x$ "--- решение системы сравнений.\\
            \underline{Шаг 1.} Определить $M = \prod_{i = 1}^{n} m_i$.\\
            \underline{Шаг 2.} Определить $c_1, \dots, c_n$, где $c_i =
            \frac{M}{m_i}$.\\
            \underline{Шаг 3.} Определить $d_1, \dots, d_n$, где $d_i = c^{-1}_i
            (mod \text{ } m_i)$. $c^{-1}_i$ находится с помощью расширенного алгоритма
            Евклида (алгоритм $2$).\\
            \underline{Шаг 4.} Результат: $x = \sum_{i = 1}^{n} c_i d_i a_i (mod \text{ } M)$.\\

            \underline{Псевдокод:}
            \begin{minted}[breaklines,fontsize=\small]{text}
            Китайская Теорема Об Остатках(a, m):
            M := 1
            ans := 0
            для каждого (ai, mi) выполнить
                M := M * mi
            для каждого (ai, mi) выполнить
                c := M / mi
                (d, x, y) := Расширенный Алгоритм Евклида(m, c)
                ans :+= ai * c * x
            вернуть ans mod M
            \end{minted}

            Сложность алгоритма $O(n^2 b^2)$, где $b$ "--- число двоичных
            знаков, с помощью которых записываются числа $c_i d_i a_i$.\\

        \underline{Алгоритм 5 - алгоритм Гарнера}\\
            \textit{Вход}: целые числа $a_1, a_2, \dots, a_n$ "--- коэффициенты
            системы линейных сравнений и сопростые числа $m_1, m_2,
            \dots, m_n$ "--- из себя модули этой системы.\\
            \textit{Выход}: целое число $x$ "--- решение системы сравнений.\\
            \underline{Шаг 1.} Определить $c_{11}, c_{12}, \dots, c_{21},
            c_{22}, \dots, c_{nn} (\forall i \in \overline{0,n} \& i \neq j)$, где $c_{ij} = m^{-1}_i (mod \text{ } m_j)$. Обратный элемент находится с помощью
            расширенного алгоритма Евклида (алгоритм $2$).\\
            \underline{Шаг 2.} Определить последовательность $Q$, которая
            изначально состоит из одного элемента $q_1$ и имеет длину $l = 1$.
            Положить $i = 0$. \\
            \underline{Шаг 3.} Положить $i = i + 1$, $q = u_i$.\\
            \underline{Шаг 4.} Для $j = 1, \dots, l$ выполнить $q = (q -
            q_j) \cdot c_{ji}$.\\
            \underline{Шаг 5.} Добавить $q (mod \text{ } m_i)$ в $Q$ и положить
            $l = l + 1$. Если $i \leq n$, перейти к шагу 3.\\
            \underline{Шаг 6.} Вернуть результат: $x = q_1 + \sum_{i =
            2}^{n} (q_i \prod_{j = 1}^{i - 1} m_i)$.

            \underline{Псевдокод:}
            \begin{minted}[breaklines,fontsize=\small]{text}
            Алгоритм Гарнера(a, m):
            n := размер массива a
            c := [[0, 0, ..., 0], ..., [0, 0, ..., 0]] // Инициализация массива длинной n на n
            q := [0, 0, ..., 0] // Инициализировать массив длинной n

            для i от 1 до n-1 включительно выполнить
                q[i] := a[i]
                для j от 1 до i включительно выполнить
                    q[i] := c[j][i] * (q[i] - q[j])
                    q[i] := q[i] mod m[i]
            m_iter := 1
            x := 0
            для i от 1 до n включительно выполнить
                x :+= q[i] * m_iter
                m_iter :*= m[i]
        
            вернуть x            
            \end{minted}


            Трудоемкость алгоритма $O(n^2 b^2)$.\\

        \underline{Алгоритм 6 - метод Гаусса решения систем линейных уравнений}\\
        \underline{над конечными полями}\\
            \textit{Вход}: Коэффициенты системы
            $a_{00}, \dots, a_{n-1,m-1}$, свободные члены системы $b_0, \dots,
            b_{n-1}$, размерность конечного поля $p$.\\
            \textit{Выход}: Если у системы есть решение, то выход: список $X =
            (\zeta_0, \dots, \zeta_{m - 1})$, который является решением системы
            уравнений. Если решения у системы нет, выход: сообщение ''Нет решения!''.\\
            \underline{Шаг 1.} Положить $i = 0$.\\
            \underline{Шаг 2.} Если $a_{t0} = \dots = a_{t,m-1} = 0 (\forall t \in \overline{0,m})$,
            но $b_i \neq 0$, то вывести в качестве результата ''Нет решения!''.\\
            \underline{Шаг 3.} Положить $a_{ij} = a_{ij} * a_{ii}^{-1} (mod \text{ } p) \& b_{i}=b{i} * a_{ii}^{-1} (mod \text{ } p) (\forall j \in \overline{i,m})$.\\
            \underline{Шаг 4.} Положить $a_{tj} = (a_{tj} - a_{ti} * a_{ij}) (mod \text{ } p) \& b_{t} = 
            (b{t} - a_{ti} * b{i}) (mod \text{ } p) (\forall j, t \in \overline{i,m} \& t \neq i)$.\\
            \underline{Шаг 5.} Положить $i+1$и вернуться к шагу 2.\\
            \underline{Шаг 6.} Удалить строки, для которых выполняется $a_{i0} = \dots = a_{0,m-1} = 0 (\forall i \in \overline{0,m})$ \\
            \underline{Шаг 7.} Положить $x_j = b_j$.\\
            \underline{Шаг 8.} Положить $k = j + 1$.\\
            \underline{Шаг 9.} Положить $x_j = (x_j - a_{jk} \cdot x_k) (mod
            \text{ } p)$.\\
            \underline{Шаг 10.} Если $k < m$, положить $k = k + 1$ и перейти к
            шагу 9.\\
            \underline{Шаг 11.} Если $j > 0$, положить $j = j - 1$ и перейти к
            шагу 7.\\
            \underline{Шаг 12.} Вернуть $X$.

            \underline{Псевдокод:}
            \begin{minted}[breaklines,fontsize=\small]{text}
            Метод Гаусса(A, B, p)
            для i от 1 до n включительно выполнить
                если A[i][i] не равно 0 то
                    A[i], B[i] :/= A[i][i] (mod p)
                    для row от 1 до n включительно выполнить
                        если row не равно i то
                            A[row] :-= A[row][i] * A[i]
                A, B := найти и удалить тривиальные строку

            для j от n-1 до 0 выполнить
                x[j] := B[j]
                Для k от j+1 до m выполнить
                    x[j] := (x[j] - A[j][k] * x[k]) (mod p)
            
            вернуть x
            \end{minted}

            Трудоемкость алгоритма $O(n^2 \cdot m)$\\
    
    \subsection{Код программы, реализующей рассмотренные алгоритмы}

        \inputminted[breaklines,fontsize=\small,linenos]{python}{../code/lab1.py}

    \subsection{Результаты тестирования программ}
        \begin{figure}[H]
            \centering
            \includegraphics[width=0.8\textwidth]{pic/1.png}
            \caption{Тест поиска НОД по алгоритмам Евклида}
        \end{figure}

        \begin{figure}[H]
            \centering
            \includegraphics[width=0.8\textwidth]{pic/2.png}
            \caption{Тест алгоритмов решения систем сравнений}
        \end{figure}

        \begin{figure}[H]
            \centering
            \includegraphics[width=0.8\textwidth]{pic/3.png}
            \caption{Тест алгоритма решения СЛУ методом Гаусса}
        \end{figure}


\conclusion

    В данной лабораторной работе были рассмотрены теоретические сведения об
    алгоритмах Евклида поиска НОД (обычного, расширенного и бинарного), 
    греко-китайская теорема об остатках и алгоритм Гарнера для решения системы сравнений,
    а также метод Гаусса для решения линейных уравнений над
    конечными полями. На их основе были реализованны соответствующие алгоритмы на языке python.
    Далее была произведена оценка сложности и тестирование данных алгоритмов, результаты которого были прикреплены к отчету вместе с
    самим листингом программы.

\end{document}